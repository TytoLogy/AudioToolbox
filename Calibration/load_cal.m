function caldata = load_cal(filename, varargin)
%--------------------------------------------------------------------------
% caldata = load_cal(filename, noinverse)
%--------------------------------------------------------------------------
%	Audio Toolbox: Calibration
%--------------------------------------------------------------------------
%	Function to read in calibration data generated by calibration programs
%
%--------------------------------------------------------------------------
%	Input Arguments:
%		filename		name of cal file (usually ear.cal)
%		noinverse	don't convert to inverse filter
%--------------------------------------------------------------------------
%	Output Arguments:
%		caldata		Matlab structure containing cal data
% 
%			Critical elements are:
% 
%				caldata.mag	
%				caldata.phase
% 
%				These are both 2XN arrays, with the first row containing
%				data for the Left channel and the second row containing
%				Right channel data.  
%				This is the convention for all calibration data
% 
% 				If arrays are 3XN, then the 3rd channel is reference mic data
%--------------------------------------------------------------------------
%	See also: GET_CAL, FAKE_FLATCAL, READEARCAL, WRITEEARCAL;
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
% Sharad J Shanbhag
% sshanbhag@neomed.edu
%--------------------------------------------------------------------------
%
% Created:	12 April, 2016
%	Supersedes load_headphone_cal.m on which it is based
%
% Revisions:
%--------------------------------------------------------------------------

if nargin ~= 2
	noinverse = 0;
else
	noinverse = 1;
end

if ~exist(filename, 'file')
	error(['Calibration file ' filename ' not found']);
end

load(filename, '-MAT');

caldata.phase_us = caldata.phase; %#ok<NODEF>
% preconvert phases from angle (RADIANS) to microsecond
if isfield(caldata, 'freq')
	caldata.phase_us(1, :) = (1.0e6 * unwrap(caldata.phase(1, :))) ./ (2 * pi * caldata.freq);
	caldata.phase_us(2, :) = (1.0e6 * unwrap(caldata.phase(2, :))) ./ (2 * pi * caldata.freq);
elseif isfield(caldata, 'Freqs')
	caldata.phase_us(1, :) = (1.0e6 * unwrap(caldata.phase(1, :))) ./ (2 * pi * caldata.Freqs);
	caldata.phase_us(2, :) = (1.0e6 * unwrap(caldata.phase(2, :))) ./ (2 * pi * caldata.Freqs);
else
	error('%s: no freq or Freqs in caldata????', mfilename)
end

% get the overall min and max dB SPL levels
caldata.mindbspl = min(caldata.mag'); %#ok<*UDIM>
caldata.maxdbspl = max(caldata.mag');

if ~noinverse
	% precompute the inverse filter, and convert to RMS value.
	caldata.maginv = zeros(2, length(caldata.mag));
	% subtract SPL mags (at each freq) from the min dB recorded for each
	% channel and convert back to Pa (rms)
	caldata.maginv(1, :) = invdb(caldata.mindbspl(1) - caldata.mag(1, :));
	caldata.maginv(2, :) = invdb(caldata.mindbspl(2) - caldata.mag(2, :));
end

if isfield(caldata, 'micsettings')
	if isfield(caldata.micsettings, 'DAscale')
		caldata.DAscale = caldata.micsettings.DAscale;
	else
		caldata.DAscale = 1;
	end
elseif isfield(caldata, 'frdata')
	if isfield(caldata.frdata, 'DAscale')
		caldata.DAscale = caldata.frdata.DAscale;
	else
		caldata.DAscale = 1;
	end	
else
	caldata.DAscale = 1;
end


